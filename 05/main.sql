-- Setup
create table if not exists input_lines (
  line_number integer generated by default as identity,
  text text not null,
  constraint input_lines_pkey primary key (line_number)
);

-- \copy input_lines (text) from 'example';
\copy input_lines (text) from 'input';

-- Part 1
with recursive
config_block_iterations as (
  (
    select 3 as index,
           cast (null as integer) as line_number,
           cast (null as text),
           cast ('{"maps": []}' as jsonb) as blocks
  )
  union all
  (
               select index + 1,
                      input_lines.line_number,
                      input_lines.text,
                      (
                        case
                        when line_type = 'map_start' then
                          jsonb_set(blocks, '{current_map}', '[]')
                        when line_type = 'map_line' then
                          jsonb_insert(blocks, '{current_map, -1}', to_jsonb(map_entry), true)
                        when line_type in ('block_end', 'input_end') and blocks ? 'current_map' then
                          jsonb_insert(blocks, '{maps, -1}', blocks->'current_map', true) - 'current_map'
                        else blocks
                        end
                      ) as blocks
                 from config_block_iterations
            left join input_lines
                   on input_lines.line_number = index
    left join lateral (
                        select (
                                 case
                                 when right(input_lines.text, 4) = 'map:' then 'map_start'
                                 when character_length(input_lines.text) = 0 then 'block_end'
                                 when input_lines.text is null then 'input_end'
                                 else 'map_line'
                                 end
                               ) as line_type
                      )
                   on true
    left join lateral (
                        select (
                                 case when line_type = 'map_line' then
                                   cast (string_to_array(input_lines.text, ' ') as bigint[])
                                 end
                               ) as map_entry
                      )
                   on true
                where index <= (
                                 select count(*) + 1
                                   from input_lines
                               )
  )
),
config_blocks as
(
    select blocks as json
      from config_block_iterations
  order by index desc
     fetch first row only
),
seeds as (
             select unnest(string_to_array(seeds_match[1], ' ')) as seed
               from input_lines
  left join lateral regexp_match(input_lines.text, '^seeds: (.*)') as seeds_match
                 on true
              where input_lines.line_number = 1
),
maps as (
             select index,
                    map
               from config_blocks
  left join lateral jsonb_array_elements(json->'maps')
                    with ordinality as t(map, index)
                 on true
),
seed_map_iterations as
(
  (
    select 1 as index,
           cast (seed as bigint) as seed,
           cast (null as bigint) as source_range_start,
           cast (seed as bigint) as value
      from seeds
  )
  union all
  (
               select seed_map_iterations.index + 1,
                      seed,
                      map_entries.source_range_start,
                      coalesce(
                        destination_range_start + (seed_map_iterations.value - map_entries.source_range_start),
                        value
                      )
                 from seed_map_iterations
    left join lateral (
                        select source_range_start,
                               destination_range_start,
                               range_length
                          from (
                                            select cast (map_entries->>0 as bigint) as destination_range_start,
                                                   cast (map_entries->>1 as bigint) as source_range_start,
                                                   cast (map_entries->>2 as bigint) as range_length
                                              from maps
                                 left join lateral jsonb_array_elements(maps.map) as map_entries
                                                on true
                                             where maps.index = seed_map_iterations.index
                               )
                         where     seed_map_iterations.value >= source_range_start
                               and seed_map_iterations.value < (source_range_start + range_length)
                         fetch first row only
                      ) as map_entries
                   on true
                where seed_map_iterations.index <= (
                                                     select count(*)
                                                       from maps
                                                   )
  )
)
  select value as result
    from seed_map_iterations
   where index = (
                   select max(index)
                     from seed_map_iterations
                 )
order by value
   fetch first row only
;

drop table input_lines cascade;
