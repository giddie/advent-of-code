-- Setup
create table if not exists input_lines (
  line_number integer generated by default as identity,
  text text not null,
  constraint input_lines_pkey primary key (line_number)
);

\copy input_lines (text) from 'input';

-- Part 1
           select sum(cast ((first || second) as integer)) as result
             from input_lines
left join lateral (
                    select (regexp_match(text, '\d'))[1] as first,
                           (regexp_match(text, '.*(\d)'))[1] as second
                  )
               on true;

-- Part 2
with line_digits as
(
              select line_number,
                     text,
                     cast (string_agg(digit, '') as integer) as digits
                from input_lines
   left join lateral (
                        select unnest(array[(regexp_match(text, '[1-9]|one|two|three|four|five|six|seven|eight|nine'))[1],
                                            (regexp_match(text, '.*([1-9]|one|two|three|four|five|six|seven|eight|nine)'))[1]]) as token
                     ) on true
   left join lateral (
                       select case token
                              when 'one' then '1'
                              when 'two' then '2'
                              when 'three' then '3'
                              when 'four' then '4'
                              when 'five' then '5'
                              when 'six' then '6'
                              when 'seven' then '7'
                              when 'eight' then '8'
                              when 'nine' then '9'
                              else token
                              end as digit
                     ) on true
            group by line_number
)
select sum(digits) as result
  from line_digits
;

-- Part 2 - Trying to match more efficiently. Turns out it's slower.
with line_digits as
(
             select line_number,
                    text,
                    case first.index
                      when 1 then cast (first.token as integer)
                      else first.index - 1
                    end as first,
                    case last.index
                      when 1 then cast (last.token as integer)
                      else last.index - 1
                    end as last
               from input_lines
  left join lateral (
                       select token, index
                         from unnest(regexp_match(text, '([1-9])|(one)|(two)|(three)|(four)|(five)|(six)|(seven)|(eight)|(nine)'))
                         with ordinality as first(token, index)
                    ) as first on true
  left join lateral (
                       select token, index
                         from unnest(regexp_match(text, '.*(?:([1-9])|(one)|(two)|(three)|(four)|(five)|(six)|(seven)|(eight)|(nine))'))
                         with ordinality as last(token, index)
                    ) as last on true
              where first.token is not null
                and last.token is not null
)
select sum(first * 10 + last) as result
  from line_digits
;

drop table input_lines;
