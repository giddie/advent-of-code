-- Setup
create table if not exists input_lines (
  line_number integer generated by default as identity,
  text text not null,
  constraint input_lines_pkey primary key (line_number)
);

-- \copy input_lines (text) from 'example';
\copy input_lines (text) from 'input';

-- Part 1
with
grouped_lines as
(
  select line_number,
         text,
         lag(text) over () as prev_line,
         lead(text) over () as next_line
    from input_lines
),
tokenised_numbers as
(
             select line_number,
                    text,
                    cast (
                      (
                        sum(prefix_length + number_length)
                          over (
                            partition by line_number
                                order by match_index
                          )
                        - number_length
                        + 1
                      )
                      as integer
                    ) as number_start_index,
                    matches[2] as number,
                    number_length,
                    prev_line,
                    next_line
               from grouped_lines
  left join lateral (
                      select *
                        from regexp_matches(text, '(.*?)(\d+)(?!\d)', 'g')
                             with ordinality
                             as t(matches, match_index)
                    )
                 on true
  left join lateral (
                      select character_length(matches[1]) as prefix_length,
                             character_length(matches[2]) as number_length
                    )
                 on true
),
search_regions as
(
  select line_number,
         text,
         number,
         prev_line,
         number_start_index,
         substring(
           text
           from ((number_start_index) - 1)
           for 1
         ) as prev_char,
         substring(
           text
           from (number_start_index + number_length)
           for 1
         ) as next_char,
         substring(
           prev_line
           from (number_start_index - 1)
           for number_length + 2
         ) as prev_line_search_region,
         substring(
           next_line
           from (number_start_index - 1)
           for number_length + 2
         ) as next_line_search_region
    from tokenised_numbers
   where number is not null
),
part_numbers as
(
             select line_number,
                    number,
                    symbol_search_string,
                    symbol_search_string ~ '[^\.\d]' as is_adjacent_to_symbol
               from search_regions
  left join lateral (
                      select    prev_char
                             || next_char
                             || coalesce(prev_line_search_region, '')
                             || coalesce(next_line_search_region, '')
                             as symbol_search_string
                    )
                 on true
)
select sum(cast(number as integer))
  from part_numbers
 where is_adjacent_to_symbol
;

drop table input_lines cascade;
