-- Setup
create table if not exists input_lines (
  line_number integer generated by default as identity,
  text text not null,
  constraint input_lines_pkey primary key (line_number)
);

-- \copy input_lines (text) from 'example';
\copy input_lines (text) from 'input';

create view cube_draws as
(
             select game_descriptor[1] as game_index,
                    draw_index,
                    count,
                    colour
               from input_lines
  left join lateral regexp_match(text, 'Game (\d+): (.*)') as game_descriptor
                 on true
  left join lateral (
                      select *
                        from unnest(string_to_array(game_descriptor[2], '; '))
                        with ordinality as t(draw_string, draw_index)
                    )
                 on true
  left join lateral unnest(string_to_array(draw_string, ', ')) as cube_descriptor_string
                 on true
  left join lateral regexp_match(cube_descriptor_string, '(\d+) (.*)') as cube_descriptor
                 on true
  left join lateral (
                      select cast (cube_descriptor[1] as integer) as count,
                             cube_descriptor[2] as colour
                    )
                 on true
);

-- Part 1
with
possible_games as
(
             select game_index
               from cube_draws
  left join lateral (
                      select    (colour = 'red' and count <= 12)
                             or (colour = 'green' and count <= 13)
                             or (colour = 'blue' and count <= 14)
                             as possible
                    )
                 on true
           group by game_index
             having bool_and(possible)
)
select sum(cast (game_index as integer)) as result
  from possible_games
;

-- Part 2
explain analyze
with
min_required as
(
    select game_index,
           colour,
           max(count) as min_required
      from cube_draws
  group by game_index,
           colour
),
min_required_json as
(
    select game_index,
           json_object_agg(colour, min_required) as min_required
      from min_required
  group by game_index
),
min_required_columns as
(
  select game_index,
         coalesce(cast (min_required->>'red' as integer), 1) as red,
         coalesce(cast (min_required->>'green' as integer), 1) as green,
         coalesce(cast (min_required->>'blue' as integer), 1) as blue
    from min_required_json
)
select sum(red * green * blue)
  from min_required_columns
;

drop table input_lines cascade;
